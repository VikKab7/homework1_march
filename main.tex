\documentclass{article}
\usepackage{graphicx} % Required for inserting images

\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{mathtext}
\usepackage{amsmath}
\usepackage{siunitx} % Required for alignment
\usepackage{multirow}
\usepackage{rotating}
\usepackage{float}
\usepackage{booktabs}
\usepackage{color, colortbl}

\usepackage[russian]{babel}

%Light gray:
\definecolor{Gray}{gray}{0.9}

\title{дз}
\author{kabakova.va }
\date{March 2025}

\begin{document}

\maketitle

\section{Вопросы}
 \paragraph{}
{1) Граф —  математическая структура, которая состоит из множества вершин (узлов) и множества ребер (как бы связи между вершинами). С помощью графа мы можем наглядно представить и понять взаимосвязи между объектами.

2) В простом графе максимальное количество ребер M зависит от количества вершин n:

Для ориентированного графа: n(n-1) (для каждой пары вершин существует максимум два ребра)

Для неориентированного графа: n(n-1)/2
Тут каждое ребро имеет направление и соединяет две вершины, а их порядок не имеет значения. 

3) Матрица смежности — это квадратная матрица, где элемент aij равен 1, если есть ребро из вершины i в вершину j, и 0, если его нет.
Если матрица симметрична, то граф неориентированный. Если симметрична, то граф ориентированный.
 
4) Список ребер:
В взвешенном графе каждая запись в списке ребер будет содержать две вершины и вес ребра. (c,d,8)
Список смежности:
Для каждой вершины хранится список пар, где каждая пара содержит соседнюю вершину и вес ребра. A:[(B,5),(C,3)] 

5) Компонента связности — это часть графа(то есть подграф, где любые две вершины соединены путем,  который не связан с другими вершинами графа. Понятно, что минимальное количество компонент в графе это 1(между двумя вершинами есть ребро). А максимальное количество компонент в графе это соотвественно n( пример: граф с n отдельных вершин)

6) Да, с помощью BFS можно искать циклы в графе, но это удобнее только для поиска кратчайших циклов(так как мы храним данные всех пройденных вершин). В DFS памяти требуется меньше(мы проходимся вперед, а потом возвращаемся обратно), поэтому естественно поиск циклов лучше делать через этот алгоритм.

7) В алгоритме на каждом шаге мы выбираем наименьшее расстояние до начальной вершины и запоминаем его. Значит когда у нас положительные значения расстояний, мы уверены что сумма будет минимальной. А если значения отрицательные, то когда мы прибавляем данное отрицательное значение, общее расстояние уменьшается, и уже нет гарантий, что оно минимальное. Наверное можно заставить алгоритм конкретно работать если поставить условие, что мы будем заново пересчитывать уже обработанные расстояния, но это будет намного тяжелее и затратнее, поэтому если есть отрицательные значения, лучше использовать другой алгоритм.(например Форда-Беллмана)

8) Запускаем алгоритм N-1 раз чтобы точно найти все кратчайшие пути, а N раз алгоритм проходит, чтобы найти цикл с отрицательным весом. Соотвественно при N запуске результат не поменялся, значит циклов с отрицательным весом нет.И как раз если у нас есть цикл с  отрицательной суммой ребер, мы можем сказать, что задача поиска кратчайшего пути некорректна, так как если запустим цикл еще один раз, получим путь ещё короче.

9)Ну во-первых, как уже говорилось ранее, алгоритм Дейкстры не работает с отрицательным весом. Во-вторых, возможно, если у нас небольшое N, то начиная с какого то числа K<N значение расстояния начинает повторяться и уже не уменьшается, поэтому алгоритм Форда-Беллмана можно сказать, что быстрее работает.




}

\end{document}
